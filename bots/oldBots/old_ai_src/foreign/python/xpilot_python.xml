<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="reference_python.xsl"?>

<header>
<category>
<name>General</name>
<desc>These functions allow general control of the Xpilot client</desc>
<function>
	<name>xpai.setargs</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>String</type>
			<name>args</name>
			<desc>a string of xpilot command-line arguments</desc>
		</var>
	</input_vars>
	<desc>Specifies command line arguments for Xpilot launch.</desc>
	<example>
#joins server on localhost:1338 with name "jim"

xpai.setargs("-name jim -join localhost -port 1338")
	</example>
</function>

<function>
	<name>xpai.launch</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
			<name></name>
			<desc></desc>
		</var>
	</input_vars>
	<desc>Launches the xpilot client with the command line argumens specified in xpai.setargs()</desc>
	<example>
#launches xpai

xpai.launch()
	</example>
</function>


<function>
	<name>xpai.setmaxturn</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>maxturn</name>
			<desc>maximum turn degrees per frame</desc>
		</var>
	</input_vars>
	<desc>Sets the maximum turn for self in degrees per frame.</desc>
</function>


<function>
	<name>xpai.teamplay</name>
	<return_var>
		<type>int</type>
		<desc>1 if teamplay enabled, 0 if not</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Sees if teamplay is enabled.</desc>
	<see_also>
		<flink>xpai.self_team</flink>
		<flink>xpai.ship_team</flink>	
	</see_also>
</function>

<function>
	<name>xpai.presskey</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>key</name>
			<desc>key number to press</desc>
		</var>
	</input_vars>
	<desc>Simulates a key press.  Usually <flink>xpai.releasekey</flink> must be called after to complete the key-stroke.
Below is a complete list of all the possible keys to press.
	</desc>
	<example>
# A ship that tries to fire a laser every 
# frame (if lasers are enabled by server  
   
def AImain(): 
	xpai.presskey(KEY_FIRE_LASER)
	xpai.releasekey(KEY_FIRE_LASER)

	</example>
	<see_also>
		<flink>xpai.releasekey</flink>
	</see_also>
	<subnote>
    KEY_DUMMY,							/* 0 */
    KEY_LOCK_NEXT,
    KEY_LOCK_PREV,
    KEY_LOCK_CLOSE,
    KEY_CHANGE_HOME,
    KEY_SHIELD,							/* 5 */
    KEY_FIRE_SHOT,
    KEY_FIRE_MISSILE,
    KEY_FIRE_TORPEDO,
    KEY_TOGGLE_NUCLEAR,		
    KEY_FIRE_HEAT,						/* 10 */
    KEY_DROP_MINE,
    KEY_DETACH_MINE,
    KEY_TURN_LEFT,
    KEY_TURN_RIGHT,
    KEY_SELF_DESTRUCT,
    KEY_LOSE_ITEM,		
    KEY_PAUSE,
    KEY_TANK_DETACH,
    KEY_TANK_NEXT,
    KEY_TANK_PREV,						/* 20 */
    KEY_TOGGLE_VELOCITY,
    KEY_TOGGLE_CLUSTER,		
    KEY_SWAP_SETTINGS,
    KEY_REFUEL,
    KEY_CONNECTOR,
    KEY_INCREASE_POWER,
    KEY_DECREASE_POWER,
    KEY_INCREASE_TURNSPEED,
    KEY_DECREASE_TURNSPEED,
    KEY_THRUST,							/* 30 */
    KEY_CLOAK,
    KEY_ECM,
    KEY_DROP_BALL,
    KEY_TRANSPORTER,
    KEY_TALK,
    KEY_FIRE_LASER,
    KEY_LOCK_NEXT_CLOSE,
    KEY_TOGGLE_COMPASS,
    KEY_TOGGLE_MINI,
    KEY_TOGGLE_SPREAD,						/* 40 */
    KEY_TOGGLE_POWER,
    KEY_TOGGLE_AUTOPILOT,
    KEY_TOGGLE_LASER,
    KEY_EMERGENCY_THRUST,
    KEY_TRACTOR_BEAM,
    KEY_PRESSOR_BEAM,
    KEY_CLEAR_MODIFIERS,
    KEY_LOAD_MODIFIERS_1,
    KEY_LOAD_MODIFIERS_2,
    KEY_LOAD_MODIFIERS_3,					/* 50 */
    KEY_LOAD_MODIFIERS_4,
    KEY_SELECT_ITEM,		
    KEY_PHASING,		
    KEY_REPAIR,
    KEY_TOGGLE_IMPLOSION,
    KEY_REPROGRAM,
    KEY_LOAD_LOCK_1,
    KEY_LOAD_LOCK_2,
    KEY_LOAD_LOCK_3,
    KEY_LOAD_LOCK_4,						/* 60 */
    KEY_EMERGENCY_SHIELD,
    KEY_HYPERJUMP,		
    KEY_DETONATE_MINES,
    KEY_DEFLECTOR,		
    KEY_UNUSED_65,
    KEY_UNUSED_66,
    KEY_UNUSED_67,
    KEY_UNUSED_68,
    KEY_UNUSED_69,
    KEY_UNUSED_70,						/* 70 */
    KEY_UNUSED_71,
    NUM_KEYS,
    KEY_MSG_1, /* talk macros */
    KEY_MSG_2,
    KEY_MSG_3,
    KEY_MSG_4,
    KEY_MSG_5,
    KEY_MSG_6,
    KEY_MSG_7,
    KEY_MSG_8,
    KEY_MSG_9,
    KEY_MSG_10,
    KEY_MSG_11,
    KEY_MSG_12,
    KEY_MSG_13,
    KEY_MSG_14,
    KEY_MSG_15,
    KEY_MSG_16,
    KEY_MSG_17,
    KEY_MSG_18,
    KEY_MSG_19,
    KEY_MSG_20,
    KEY_ID_MODE,
    KEY_TOGGLE_OWNED_ITEMS,
    KEY_TOGGLE_MESSAGES,
    KEY_POINTER_CONTROL,
    KEY_TOGGLE_RECORD,
    KEY_PRINT_MSGS_STDOUT,
    KEY_TALK_CURSOR_LEFT,
    KEY_TALK_CURSOR_RIGHT,
    KEY_TALK_CURSOR_UP,
    KEY_TALK_CURSOR_DOWN,
    KEY_SWAP_SCALEFACTOR,
	</subnote>
</function>

<function>
	<name>xpai.releasekey</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>key</name>
			<desc>key number to release</desc>
		</var>
	</input_vars>
	<desc>Simulates a key release.  Call to release a key pressed by <flink>xpai.pressKey</flink>.
See <flink>xpai.pressKey</flink> for a complete list of keys.
	</desc>
	<example>
# A ship that tries to fire a laser every
# frame (if lasers are enabled by server  
	
def AImain():
	xpai.presskey(KEY_FIRE_LASER);
	xpai.releasekey(KEY_FIRE_LASER);

	</example>
	<see_also>
		<flink>xpai.presskey</flink>
	</see_also>
</function>
</category>


<category>
<name>Self Control</name>
<desc>Functions to control the ship</desc>
<function>
	<name>xpai.self_thrust</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>thrust</name>
			<desc>1 to thrust, 0 to not thrust.</desc>
		</var>
	</input_vars>
	<desc>Controls the ship's thrust.  1 to thrust, 0 to not thrust.  Resets to not-thrust after every frame.</desc>
	<example>
# a ship that thrusts every frame

def AImain():
	xpai.self_thrust(1)

	</example>
	<see_also>
		<flink>xpai.self_turn</flink>
		<flink>xpai.self_shoot</flink>
		<flink>xpai.self_shield_enable</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_turn</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>turn</name>
			<desc>degrees to turn</desc>
		</var>
	</input_vars>
	<desc>Turns the ship <i>turn</i> degrees (out of 360).  Negative degrees are counter-clockwise, positive clockwise.</desc>
	<example>
#a ship that turns 15 degrees clockwise every frame

def AImain():
	xpai.self_turn(15);

	</example>
	<see_also>
		<flink>xpai.setmaxturn</flink>
		<flink>xpai.self_thrust</flink>
		<flink>xpai.self_shoot</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>
		<flink>xpai.self_shield_enable</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_shoot</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>shoot</name>
			<desc>1 to shoot, 0 to not shoot.</desc>
		</var>
	</input_vars>
	<desc>Makes the ship shoot.  1 to shoot, 0 to not shoot.  Servers limit the shot rate and the number of shots, so AIself_shoot(1) will not always cause a shot to be fired.  Use <flink>AIself_reload</flink> to check the number of frames remaining before it is possible to shoot again.</desc>
	<example>
# a ship that waits until "reload" 
   says it can shoot and then shoots 
   
def AImain():
	if (xpai.self_reload() == 0):
		xpai.self_shoot(1)
	</example>
	<see_also>
		<flink>xpai.self_reload</flink>
		<flink>xpai.self_turn</flink>
		<flink>xpai.self_thrust</flink>
		<flink>xpai.self_shield_enable</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_shield_enable</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>shield</name>
			<desc>1 to enable, 0 to disable.</desc>
		</var>
	</input_vars>
	<desc>Turns on or off the ship's shield.  Use <flink>AIself_shield</flink> to see the status of the shield.</desc>
	<example>
# a ship whose shield is always on
def: AImain():
	xpai.self_shield_enable(1)

	</example>
	<see_also>
		<flink>xpai.self_shield</flink>
		<flink>xpai.self_turn</flink>
		<flink>xpai.self_thrust</flink>
		<flink>xpai.self_shoot</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_destruct</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Start or stop the self-destruct sequence.</desc>
</function>
</category>


<category>
<name>Self Variables</name>
<desc>Functions that return values of variables concerning the self ship.</desc>

<function>
	<name>xpai.self_id</name>
	<return_var>
		<type>int</type>
		<desc>self's id</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>The id of self's ship, according to the server.</desc>
	<see_also>
		<flink>xpai.ship_id</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_alive</name>
	<return_var>
		<type>int</type>
		<desc>1 if self is alive, else 0</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
</function>

<function>
	<name>xpai.self_x</name>
	<return_var>
		<type>int</type>
		<desc>self's x position</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's x position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_y</flink>
		<flink>xpai.ship_x</flink>
		<flink>xpai.radar_x</flink>
		<flink>xpai.shot_x</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_y</name>
	<return_var>
		<type>int</type>
		<desc>self's y position</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's y position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_x</flink>
		<flink>xpai.ship_y</flink>
		<flink>xpai.radar_y</flink>
		<flink>xpai.shot_y</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_vel</name>
	<return_var>
		<type>int</type>
		<desc>self's velocity</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's velocity (number of pixels moved per frame).</desc>
	<see_also>
		<flink>xpai.self_track</flink>
		<flink>xpai.ship_vel</flink>
		<flink>xpai.shot_vel</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_heading</name>
	<return_var>
		<type>int</type>
		<desc>self's heading</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's heading (direction ship's nose is pointing).  0 degrees is to the right and 90 degrees is straight up.</desc>
	<see_also>
		<flink>xpai.self_track</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_track</name>
	<return_var>
		<type>int</type>
		<desc>self's track</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's track (direction of movement).  0 degrees is to the right and 90 degrees is straight up.</desc>
	<see_also>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_mapx</name>
	<return_var>
		<type>int</type>
		<desc>self's x position</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's x position on radar map, using radar map units.</desc>
	<see_also>
		<flink>xpai.self_mapy</flink>
		<flink>xpai.self_x</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_mapy</name>
	<return_var>
		<type>int</type>
		<desc>self's y position</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Self's y position on radar map, using radar map units.</desc>
	<see_also>
		<flink>xpai.self_mapx</flink>
		<flink>xpai.self_y</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_team</name>
	<return_var>
		<type>int</type>
		<desc>self's team</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai._teamplay</flink>
		<flink>xpai.ship_team</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_life</name>
	<return_var>
		<type>int</type>
		<desc>number of self's remaining lives</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.ship_life</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_shield</name>
	<return_var>
		<type>int</type>
		<desc>1 if shield is on, 0 if off</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.ship_shield</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_name</name>
	<return_var>
		<type>String</type>
		<desc>self's name</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.ship_name</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_score</name>
	<return_var>
		<type>float</type>
		<desc>self's total point score</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.self_HUD_score</flink>		
	</see_also>
</function>

<function>
	<name>xpai.self_reload</name>
	<return_var>
		<type>int</type>
		<desc>remaining reload time</desc>
	</return_var>
	<input_vars>
		<var>
			<type>void</type>
		</var>
	</input_vars>
	<desc>Number of frames remaining before self is able to shoot.  When 0, self is able to shoot.</desc>
	<see_also>
		<flink>xpai.ship_reload</flink>		
	</see_also>
</function>

</category>



<category>
<name>Ships</name>
<desc>Functions returning information about other ships on screen.  The ships are sorted from nearest to furthest.</desc>

<function>
	<name>xpai.ship_x</name>
	<return_var>
		<type>int</type>
		<desc>ship's x position, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's x position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_x</flink>
		<flink>xpai.ship_y</flink>
		<flink>xpai.radar_x</flink>
		<flink>xpai.shot_x</flink>		
	</see_also>
</function>

<function>
	<name>xpai.ship_y</name>
	<return_var>
		<type>int</type>
		<desc>ship's y position, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's y position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_y</flink>
		<flink>xpai.ship_x</flink>
		<flink>xpai.radar_y</flink>
		<flink>xpai.shot_y</flink>		
	</see_also>
</function>

<function>
	<name>xpai.ship_heading</name>
	<return_var>
		<type>int</type>
		<desc>ship's heading, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's heading (angle nose is pointing).  0 degrees is to the right, and 90 straight up.</desc>
	<see_also>
		<flink>xpai.ship_track</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.ship_track</name>
	<return_var>
		<type>int</type>
		<desc>ship's track, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's track (direction of velocity).  0 degrees is to the right, and 90 straight up.</desc>
	<see_also>
		<flink>xpai.ship_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.ship_vel</name>
	<return_var>
		<type>int</type>
		<desc>ship's velocity, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's velocity in pixels/frame.</desc>
	<see_also>
		<flink>xpai.self_vel</flink>
		<flink>xpai.shot_vel</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_dist</name>
	<return_var>
		<type>int</type>
		<desc>ship's distance from self, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Ship's distance from self, in pixels.</desc>
	<see_also>
		<flink>xpai.radar_dist</flink>
		<flink>xpai.shot_dist</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_id</name>
	<return_var>
		<type>int</type>
		<desc>id of ship, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>server assigned id of ship</desc>
	<see_also>
		<flink>xpai.self_id</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_xdir</name>
	<return_var>
		<type>int</type>
		<desc>ship's xdir, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Direction of ship from self.  0 degrees is to the right and 90 upright.</desc>
	<example>
# Self always points at nearest on screen ship
def AImain():
	if (xpai.ship_x(0) != -1):
		xpai.self_turn(xpai.anglediff(xpai.self_heading(), xpai.ship_xdir(0)))

	</example>
	<see_also>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
		<flink>xpai.radar_xdir</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_shield</name>
	<return_var>
		<type>int</type>
		<desc>1 if ship's shield is on, 0 if not, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.self_shield</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_life</name>
	<return_var>
		<type>int</type>
		<desc>number of lives remaining for ship, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.self_life</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_team</name>
	<return_var>
		<type>int</type>
		<desc>team of ship, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.self_team</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_reload</name>
	<return_var>
		<type>int</type>
		<desc>reload time of ship, or -1 if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>This is the number of frames remaining before the ship can fire again.  This number is just an estimate, and may not always be correct.</desc>
	<see_also>
		<flink>xpai.self_reload</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_name</name>
	<return_var>
		<type>String</type>
		<desc>name of ship, or NULL if ship not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.self_name</flink>
	</see_also>
</function>

<function>
	<name>xpai.ship_aimdir</name>
	<return_var>
		<type>int</type>
		<desc>aimdir</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Calculates the direction that self would need to point to hit the ship, according to self's track and velocity, the enemy ship's track and velocity, and the default bullet's shotspeed.  This is a pretty deadly function.  Sometimes it can't calculate correctly and returns some negative number.</desc>
	<example>
#bot that aims and shoots at nearest ship

def AImain():
	if (xpai.ship_x(0) != -1): 
		xpai.self_turn(xpai.anglediff(xpai.self_heading(), xpai.ship_aimdir(0)))
		xpai.self_shoot(1)
	</example>
	<see_also>
		<flink>xpai.ship_xdir</flink>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>	
	</see_also>
</function>

</category>



<category>
<name>Radar</name>
<desc>Functions returning information about other ships on the radar.  The ships are sorted from nearest to furthest.</desc>

<function>
	<name>xpai.radar_x</name>
	<return_var>
		<type>int</type>
		<desc>ship's x position, or -1 if no more ships on radar.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on radar, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Radar ship's x position (approximate), where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_x</flink>
		<flink>xpai.ship_x</flink>
		<flink>xpai.radar_y</flink>
		<flink>xpai.shot_x</flink>		
	</see_also>
</function>

<function>
	<name>xpai.radar_y</name>
	<return_var>
		<type>int</type>
		<desc>ship's y position, or -1 if no more ships on radar.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on radar, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Radar ship's y position (approximate), where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_y</flink>
		<flink>xpai.ship_y</flink>
		<flink>xpai.radar_x</flink>
		<flink>xpai.shot_y</flink>		
	</see_also>
</function>

<function>
	<name>xpai.radar_dist</name>
	<return_var>
		<type>int</type>
		<desc>ship's distance from self, or -1 if no more ships on radar.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on radar, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Radar ship's distance from self, in pixels (approximate).</desc>
	<see_also>
		<flink>xpai.ship_dist</flink>
		<flink>xpai.shot_dist</flink>
	</see_also>
</function>


<function>
	<name>xpai.radar_xdir</name>
	<return_var>
		<type>int</type>
		<desc>ship's xdir, or -1 if no more ships on radar.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on radar, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Direction of radar ship from self.  0 degrees is to the right and 90 upright.</desc>
	<example>
#self always points at second-nearest radar ship
def AImain():
	if (xpai.radar_x(1) != -1)
		xpai.self_turn(anglediff(xpai.self_heading(), xpai.radar_xdir(1)))
	</example>
	<see_also>
		<flink>xpai.self_heading</flink>
		<flink>xpai.ship_xdir</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.radar_enemy</name>
	<return_var>
		<type>int</type>
		<desc>1 if enemy, 0 if friend, or -1 if no more ships on radar.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which ship on radar, sorted near to far</desc>
		</var>
	</input_vars>
	<see_also>
		<flink>xpai.ship_team</flink>
	</see_also>
</function>

</category>




<category>
<name>Shots</name>
<desc>Functions returning information about the shots on screen.</desc>

<function>
	<name>xpai.shot_x</name>
	<return_var>
		<type>int</type>
		<desc>shot's x position, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>shot's x position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_x</flink>
		<flink>xpai.shot_y</flink>
	</see_also>
</function>

<function>
	<name>xpai.shot_y</name>
	<return_var>
		<type>int</type>
		<desc>shot's y position, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>shot's y position, where bottom left of map is [0, 0].</desc>
	<see_also>
		<flink>xpai.self_y</flink>
		<flink>xpai.shot_x</flink>
	</see_also>
</function>

<function>
	<name>xpai.shot_track</name>
	<return_var>
		<type>int</type>
		<desc>shot's track, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>shot's track (direction of velocity).  0 degrees is to the right, and 90 straight up.</desc>
	<see_also>
		<flink>xpai.shot_vel</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.shot_vel</name>
	<return_var>
		<type>int</type>
		<desc>shot's velocity, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>shot's velocity in pixels/frame.</desc>
	<see_also>
		<flink>xpai.ship_vel</flink>
		<flink>xpai.shot_track</flink>
	</see_also>
</function>

<function>
	<name>xpai.shot_dist</name>
	<return_var>
		<type>int</type>
		<desc>shot's distance from self, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>shot's distance from self, in pixels.</desc>
	<see_also>
		<flink>xpai.ship_dist</flink>
		<flink>xpai.radar_dist</flink>
	</see_also>
</function>

<function>
	<name>xpai.shot_imaginary</name>
	<return_var>
		<type>int</type>
		<desc>1 if shot imaginary, 0 if not, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Imaginary shots are calculated for every ship on screen.  If a ship were to shoot this frame, imaginary bullets tell that shots attributes.</desc>
	<see_also>
		<flink>xpai.shot_x</flink>
	</see_also>
</function>

<function>
	<name>xpai.shot_xdir</name>
	<return_var>
		<type>int</type>
		<desc>shot's xdir, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Direction of shot from self.  0 degrees is to the right and 90 upright.</desc>
	<see_also>
		<flink>xpai.shot_idir</flink>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.shot_idir</name>
	<return_var>
		<type>int</type>
		<desc>shot's intercept dir, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Direction of the location where the shot will be nearest to self, if both self velocity and bullet velocity remain constant.  0 degrees is to the right and 90 upright.</desc>
	<example>
/*self turns away from intercept dir and thrusts*/

void AImain():
	if (xpai.shot_x(0) != -1):
		xpai.self_turn(anglediff(xpai.self_heading(), angleadd(xpai.shot_idir(0), 180)))

	</example>
	<see_also>
		<flink>xpai.shot_idist</flink>
		<flink>xpai.shot_itime</flink>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.shot_idist</name>
	<return_var>
		<type>int</type>
		<desc>shot's intercept distance, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Distance to the location where the shot will be nearest to self, if both self velocity and bullet velocity remain constant, in pixels.</desc>
	<see_also>
		<flink>xpai.shot_idir</flink>
		<flink>xpai.shot_itime</flink>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.shot_itime</name>
	<return_var>
		<type>int</type>
		<desc>shot's time to intercept, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>Number of frames until the nearest intercept will occur, if both self velocity and bullet velocity remain constant.</desc>
	<see_also>
		<flink>xpai.shot_idir</flink>
		<flink>xpai.shot_idist</flink>
		<flink>xpai.self_heading</flink>
		<flink>xpai.anglediff</flink>
		<flink>xpai.angleadd</flink>		
	</see_also>
</function>

<function>
	<name>xpai.shot_alert</name>
	<return_var>
		<type>int</type>
		<desc>alert value of shot, or -1 if shot not on screen.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which shot on screen, sorted near to far</desc>
		</var>
	</input_vars>
	<desc>A value derived from <flink>xpai.shot_idist</flink> and <flink>xpai.shot_itime</flink>.  An alert between 0 and 30 means that self will probably be killed by the shot, 30 to 120, that it is a dangerous shot and should be avoided, and above 120, it's not very dangerous.  This variable is just for convience, and should probably not be used in more advanced controllers.</desc>
	<see_also>
		<flink>xpai.self_reload</flink>
	</see_also>
</function>
</category>


<category>
<name>Walls and Map</name>
<desc>Functions to check for walls and to look at map tiles</desc>

<function>
	<name>xpai.wallbetween</name>
	<return_var>
		<type>int</type>
		<desc>distance to nearest wall between [x1, y1] and [x2, y2].  Or -1 if no wall.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>x1</name>
			<desc>x coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>y1</name>
			<desc>y coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>x2</name>
			<desc>x coordinate of second point</desc>
		</var>			
		<var>
			<type>int</type>
			<name>y2</name>
			<desc>y coordinate of second point</desc>
		</var>
	</input_vars>
	<desc>This function checks for walls in a straight line starting from point [x1, y1] to point [x2, y2].  If it finds a wall, it returns the distance (in pixels) from [x1, y1] to that point.  If gets to [x2, y2] without finding a wall, it returns -1.</desc>
	<example>
# this checks for a wall 200 pixels
   in front of the ships track 

wall_N = xpai.wallbetween (	/
	xpai.self_x(), 	/
	xpai.self_y(),		/
	xpai.self_x() + 200 * cos(xpai.rad(xpai.self_track())),	
	xpai.self_y() + 200 * sin(xpai.rad(xpai.self_track())))
	</example>	
	<see_also>
		<flink>xpai.wallbetween_x</flink>
		<flink>xpai.wallbetween_y</flink>
	</see_also>
</function>

<function>
	<name>xpai.wallbetween_x</name>
	<return_var>
		<type>int</type>
		<desc>x coordinate of nearest wall between [x1, y1] and [x2, y2].  Or -1 if no wall.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>x1</name>
			<desc>x coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>y1</name>
			<desc>y coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>x2</name>
			<desc>x coordinate of second point</desc>
		</var>			
		<var>
			<type>int</type>
			<name>y2</name>
			<desc>y coordinate of second point</desc>
		</var>
	</input_vars>
	<desc>This function checks for walls in a straight line starting from point [x1, y1] to point [x2, y2].  If it finds a wall, it returns the x coordinate of that wall.  If gets to [x2, y2] without finding a wall, it returns -1.</desc>
	<see_also>
		<flink>xpai.wallbetween</flink>
		<flink>xpai.wallbetween_y</flink>
	</see_also>
</function>

<function>
	<name>xpai.wallbetween_y</name>
	<return_var>
		<type>int</type>
		<desc>y coordinate of nearest wall between [x1, y1] and [x2, y2].  Or -1 if no wall.</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>x1</name>
			<desc>x coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>y1</name>
			<desc>y coordinate of first point</desc>
		</var>
		<var>
			<type>int</type>
			<name>x2</name>
			<desc>x coordinate of second point</desc>
		</var>			
		<var>
			<type>int</type>
			<name>y2</name>
			<desc>y coordinate of second point</desc>
		</var>
	</input_vars>
	<desc>This function checks for walls in a straight line starting from point [x1, y1] to point [x2, y2].  If it finds a wall, it returns the y coordinate of that wall.  If gets to [x2, y2] without finding a wall, it returns -1.</desc>
	<see_also>
		<flink>xpai.wallbetween</flink>
		<flink>xpai.wallbetween_x</flink>
	</see_also>
</function>


<function>
	<name>xpai.map_get</name>
	<return_var>
		<type>unsigned int</type>
		<desc>bit flags for tile at (mapx, mapy)</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>mapx</name>
			<desc>mapx coordinate</desc>
		</var>
		<var>
			<type>int</type>
			<name>mapy</name>
			<desc>mapy coordinate</desc>
		</var>
	</input_vars>
	<desc>The map consists of tiles which are 35x35 pixels each.  Each tile contains information about that spot on the map, and can have multiple values.  For instance, a square block tile may have 5 bit flags set; one for each side, and one to indicate it is a wall tile.  The possible flags are listed below.  Use the bitwise "and" operator to check the tiles for the flags.  To convert a regular game coordinate to a map coordinate, use <flink>tomap</flink> and <flink>frmap</flink>.</desc>
	<example>
# checks to see if the map tile to the immediate
# right of the player contains a wall of some sort

if (xpai.map_get(xpai.tomap(xpai.self_x()) + 1, xpai.tomap(xpai.self_y()) + 1) &amp; BLUE_BIT):
	print "To the right is a wall tile!\n"
	</example>
	<see_also>
		<flink>xpai.map_set</flink>
		<flink>xpai.tomap</flink>
		<flink>xpai.frmap</flink>
	</see_also>
	<subnote>
SETUP_SPACE		0
SETUP_FILLED		1
SETUP_FILLED_NO_DRAW	2
SETUP_FUEL		3
SETUP_REC_RU		4
SETUP_REC_RD		5
SETUP_REC_LU		6
SETUP_REC_LD		7
SETUP_ACWISE_GRAV	8
SETUP_CWISE_GRAV	9
SETUP_POS_GRAV		10
SETUP_NEG_GRAV		11
SETUP_WORM_NORMAL	12
SETUP_WORM_IN		13
SETUP_WORM_OUT		14
SETUP_CANNON_UP		15
SETUP_CANNON_RIGHT	16
SETUP_CANNON_DOWN	17
SETUP_CANNON_LEFT	18
SETUP_SPACE_DOT		19
SETUP_TREASURE		20	/* + team number (10) */
SETUP_BASE_LOWEST	30	/* lowest base number */
SETUP_BASE_UP		30	/* + team number (10) */
SETUP_BASE_RIGHT	40	/* + team number (10) */
SETUP_BASE_DOWN		50	/* + team number (10) */
SETUP_BASE_LEFT		60	/* + team number (10) */
SETUP_BASE_HIGHEST	69	/* highest base number */
SETUP_TARGET		70	/* + team number (10) */
SETUP_CHECK		80	/* + check point number (26) */
SETUP_ITEM_CONCENTRATOR	110
SETUP_DECOR_FILLED	111
SETUP_DECOR_RU		112
SETUP_DECOR_RD		113
SETUP_DECOR_LU		114
SETUP_DECOR_LD		115
SETUP_DECOR_DOT_FILLED	116
SETUP_DECOR_DOT_RU	117
SETUP_DECOR_DOT_RD	118
SETUP_DECOR_DOT_LU	119
SETUP_DECOR_DOT_LD	120
SETUP_UP_GRAV		121
SETUP_DOWN_GRAV		122
SETUP_RIGHT_GRAV	123
SETUP_LEFT_GRAV		124
SETUP_ASTEROID_CONCENTRATOR	125

BLUE_UP			0x01
BLUE_RIGHT		0x02
BLUE_DOWN		0x04
BLUE_LEFT		0x08
BLUE_OPEN		0x10	/* diagonal botleft -> rightup */
BLUE_CLOSED		0x20	/* diagonal topleft -> rightdown */
BLUE_FUEL		0x30	/* when filled block is fuelstation */
BLUE_BELOW		0x40	/* when triangle is below diagonal */
BLUE_BIT		0x80	/* set when drawn with blue lines */

DECOR_LEFT		0x01
DECOR_RIGHT		0x02
DECOR_DOWN		0x04
DECOR_UP		0x08
DECOR_OPEN		0x10
DECOR_CLOSED	0x20
DECOR_BELOW		0x40
	</subnote>
</function>

<function>
	<name>xpai.map_set</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>mapx</name>
			<desc>mapx coordinate</desc>
		</var>
		<var>
			<type>int</type>
			<name>mapy</name>
			<desc>mapy coordinate</desc>
		</var>
		<var>
			<type>unsigned int</type>
			<name>value</name>
			<desc>new map tile value</desc>
		</var>
	</input_vars>
	<desc>The map tiles in Xpilot-AI are 32 bits.  Only the lowest order bits are used for Xpilot, so the other bits can be set as desired.</desc>
	<example>
# Sets a bit flag on the map tile underneath self

newtile = xpai.map_get(xpai.tomap(xpai.self_x()), xpai.tomap(xpai.self_y()))
newtile = newtile | 0x1000
xpai.map_set(xpai.tomap(xpai.self_x()), xpai.tomap(xpai.self_y()), newtile)
	</example>
	<see_also>
		<flink>xpai.map_get</flink>
		<flink>xpai.tomap</flink>
		<flink>xpai.frmap</flink>
	</see_also>
</function>

<function>
	<name>xpai.tomap</name>
	<return_var>
		<type>int</type>
		<desc>map tile</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>n</name>
			<desc>game pixel value</desc>
		</var>
	</input_vars>
	<desc>Converts a gamplay pixel value to a map value.</desc>
	<see_also>
		<flink>xpai.map_get</flink>
		<flink>xpai.map_set</flink>
		<flink>xpai.frmap</flink>
	</see_also>
</function>

<function>
	<name>xpai.frmap</name>
	<return_var>
		<type>int</type>
		<desc>game pixel</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>mapn</name>
			<desc>map value</desc>
		</var>
	</input_vars>
	<desc>Takes a map value and returns the middle of that map tile, in pixels.</desc>
	<see_also>
		<flink>xpai.map_get</flink>
		<flink>xpai.map_set</flink>
		<flink>xpai.tomap</flink>
	</see_also>
</function>
</category>

<category>
<name>Messages</name>
<desc>Write and recieve messages using the player-to-player messaging system in Xpilot</desc>

<function>
	<name>xpai.talk</name>
	<return_var>
		<type>void</type>
	</return_var>
	<input_vars>
		<var>
			<type>String</type>
			<name>message</name>
		</var>
	</input_vars>
	<desc>Say a message through the player-to-player talk system in Xpilot.</desc>
	<note>Sometimes xpilot servers kick out players that type too much, or send two messages in on frame.  Because of this, if xpai.talk is called more than once per frame, it will automatically spread sending the messages over several frames.</note>
	<example>
# Writes a message to everyone 
	xpai.talk("Hello everyone")
# Writes a private message to a player named "Jimmy" 
	xpai.talk("Jimmy: hello I'm at (22, 1004)")
# Change to team 5 */
	xpai.talk("/team 5")
	</example>
	<see_also>
		<flink>xpai.msg_to</flink>
		<flink>xpai.msg_from</flink>
		<flink>xpai.msg_body</flink>
	</see_also>
</function>

<function>
	<name>xpai.msg_to</name>
	<return_var>
		<type>String</type>
		<desc>player's name, or NULL if a public message or no more messages</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which message out of all recieved in frame</desc>
		</var>
	</input_vars>
	<desc>Look at a private message's "to" field from the player-to-player messaging system.  Returns NULL if there is no "to" field either because there is no message or it is a public message.</desc>
	<see_also>
		<flink>xpai.talk</flink>
		<flink>xpai.msg_from</flink>
		<flink>xpai.msg_body</flink>
	</see_also>
</function>

<function>
	<name>xpai.msg_from</name>
	<return_var>
		<type>String</type>
		<desc>player's name, or NULL if no more messages</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which message out of all recieved in frame</desc>
		</var>
	</input_vars>
	<desc>Look at a message's "from" field from the player-to-player messaging system.  Returns NULL if there are no messages.</desc>
	<see_also>
		<flink>xpai.talk</flink>
		<flink>xpai.msg_to</flink>
		<flink>xpai.msg_body</flink>
	</see_also>
</function>


<function>
	<name>xpai.msg_body</name>
	<return_var>
		<type>String</type>
		<desc>body of message, or NULL if no messages</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>which message out of all recieved in frame</desc>
		</var>
	</input_vars>
	<desc>Look at a message's "body" field from the player-to-player messaging system.  Returns NULL if there are no messages.</desc>
	<example>
# cycles through all the messages recieved
   every frame and prints the body

i = 0
while (xpai.msg_body(i) != null):
	print "%s\n", xpai.msg_body(i)
	i++

	</example>
	<see_also>
		<flink>xpai.talk</flink>
		<flink>xpai.msg_to</flink>
		<flink>xpai.msg_from</flink>
	</see_also>
</function>

</category>



<category>
<name>HUD</name>
<desc>The HUD is the informative box around the self's ship.  These functions access various information from the HUD, like the info about who killed who (Useful for determing kills).</desc>

<function>
	<name>xpai.self_HUD_name</name>
	<return_var>
		<type>String</type>
		<desc>name on HUD slot, or NULL if no more messages</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>HUD slot</desc>
		</var>
	</input_vars>
	<desc>Look at a HUD slot's name field.  Returns "" if there is no name in that slot.</desc>
	<see_also>
		<flink>xpai.self_HUD_score</flink>
		<flink>xpai.self_HUD_name</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_HUD_score</name>
	<return_var>
		<type>float</type>
		<desc>score on HUD slot, or -99999.0 if empty</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>HUD slot</desc>
		</var>
	</input_vars>
	<desc>Look at a HUD slot's score field.  It is best to check for empty slots using <flink>xpai.self_HUD_time</flink>.</desc>
	<see_also>
		<flink>xpai.self_HUD_time</flink>
		<flink>xpai.self_HUD_name</flink>
	</see_also>
</function>

<function>
	<name>xpai.self_HUD_time</name>
	<return_var>
		<type>int</type>
		<desc>time of HUD slot, or -1 if slot is empty</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>which</name>
			<desc>HUD slot</desc>
		</var>
	</input_vars>
	<desc>Number of frames that the HUD message has been on the HUD slot.  When a score first appears it will have a value of 0, then increase each frame thereafter until it gets to about 99.<flink>xpai.self_HUD_time</flink>.</desc>
	<example>
# check for and print out any names with positive points in HUD 
i = 0
while (xpai.self_HUD_time(i) != -1):
	if (xpai.self_HUD_time(i) == 0 and xpai.self_HUD_score(i) >= 0.0):
		print "You killed: %s\n", xpai.self_HUD_name(i)
                i++

	</example>
	<see_also>
		<flink>xpai.self_HUD_score</flink>
		<flink>xpai.self_HUD_name</flink>
	</see_also>
</function>
</category>




<category>
<name>Math Functions</name>
<desc>Useful math functions</desc>

<function>
	<name>xpai.anglediff</name>
	<return_var>
		<type>int</type>
		<desc>difference between angles</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>angle1</name>
			<desc>first angle</desc>
		</var>
		<var>
			<type>int</type>
			<name>angle2</name>
			<desc>second angle</desc>
		</var>	
	</input_vars>
	<desc>Returns the smallest angle which angle1 could add to itself to be equal to angle2.  This is useful for turning particular directions.</desc>
	<example>
	xpai.anglediff(90, 70) = -20
	xpai.anglediff(350, 10) = 20
	</example>
	<see_also>
		<flink>xpai.angleadd</flink>
		<flink>xpai.rad</flink>
		<flink>xpai.deg</flink>
	</see_also>
</function>

<function>
	<name>xpai.angleadd</name>
	<return_var>
		<type>int</type>
		<desc>addition of two angles</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>angle1</name>
			<desc>first angle</desc>
		</var>
		<var>
			<type>int</type>
			<name>angle2</name>
			<desc>second angle</desc>
		</var>	
	</input_vars>
	<desc>Adds two angles together.</desc>
	<example>
	xpai.angleadd(90, 70) = 160
	xpai.angleadd(350, 40) = 30
	</example>
	<see_also>
		<flink>xpai.angleadd</flink>
		<flink>xpai.rad</flink>
		<flink>xpai.deg</flink>
	</see_also>
</function>

<function>
	<name>xpai.rad</name>
	<return_var>
		<type>float</type>
		<desc>radians</desc>
	</return_var>
	<input_vars>
		<var>
			<type>int</type>
			<name>deg</name>
			<desc>angle in degrees</desc>
		</var>
	</input_vars>
	<desc>Converts a degree angle to radian, which is used in sin, cos, and tan.</desc>
	<see_also>
		<flink>xpai.deg</flink>
		<flink>xpai.angleadd</flink>
		<flink>xpai.anglediff</flink>
	</see_also>
</function>

<function>
	<name>xpai.deg</name>
	<return_var>
		<type>float</type>
		<desc>degrees</desc>
	</return_var>
	<input_vars>
		<var>
			<type>float</type>
			<name>rad</name>
			<desc>angle in radians</desc>
		</var>
	</input_vars>
	<desc>Converts a radian angle to degree, which is used in gameplay.</desc>
	<see_also>
		<flink>xpai.rad</flink>
		<flink>xpai.angleadd</flink>
		<flink>xpai.anglediff</flink>
	</see_also>
</function>
</category>
</header>


